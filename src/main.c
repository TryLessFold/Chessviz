#include<stdlib.h>
#include<stdio.h>
#include "ChessOut.h"
#include <iostream>

using namespace std;

void SwapMove(int *k, int *r)
{
    *r = *k;
    *k = 0;
}
int CheckMove(int **a, int y, int x, int y1, int x1)
{
	int chmove, CheckPlace, k = 0, i, j;
	if (a[y][x] != 0)
	{
		if (a[y][x] > 7) chmove = a[y][x]%6;
		else chmove = a[y][x];
		switch (chmove)
		{
		case 1:
			if ((a[y1][x1] == 0) && (y == 6))
				if ((&a[y - 1][x] == &a[y1][x1]) || (&a[y - 2][x] == &a[y1][x1])) return 1; 
			if (a[y1][x1] == 0)
				if ((&a[y - 1][x] == &a[y1][x1])) return 1; 
			if ((a[y][x] / 7 != a[y1][x1] / 7))
			{
				if ((&a[y - 1][x + 1] == &a[y1][x1]) || (&a[y - 1][x - 1] == &a[y1][x1])) return 2;
			} 
			if ((&a[y - 1][x + 1] == &a[y1][x1]) || (&a[y - 1][x - 1] == &a[y1][x1])) return 3; 
			return 0;
			break;
		      
		case 2:
			if ((x1 != x) && (y1 != y)) return 0; 
			if (x1 == x) 
			{
				if ((y1 - y)>0) //игрок ходит в нижнюю часть доски
				{
					for (i = y+1; i<y1; i++)
					{
						if (a[i][x] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((y1 - y)<0) // игрок ходит в верхнюю часть доски
				{
					for (i = y-1; i>y1; i--)
					{
						if (a[i][x] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if (y1 == y) //игрок ходит по горизонтале 
			{
				if ((x1 - x)>0) //игрок ходит в правую часть доски
				{
					for (i = x+1; i<x1; i++)
					{
						if (a[y][i] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((x1 - x)<0) // игрок ходит в левую часть доски
				{
					for (i = x-1; i>x1; i--)
					{
						if (a[y][i] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			k++;
			if (((x == x1) && (abs(y - y1) == k)) || ((y == y1) && (abs(x - x1) == k)))
			{
				if (((a[y1][x1]) != 0) && (a[y1][x1] / 7 == 0)) return 3;
				else if (a[y1][x1] >= 7) return 2;
				return 1;
			}
			else return 0; // attack
			break;
			//конь(белая(ый))
		case 3:
			if (((abs(x1 - x) == 1) && (abs(y1 - y) == 2)) || ((abs(x1 - x) == 2) && (abs(y1 - y) == 1)))
			{
				if (a[y1][x1] == 0) return 1;
				else if (((a[y1][x1]) != 0) && (a[y1][x1] / 7 == 0)) return 3;
				else return 2;
			}
			else return 0;
			break;
			//слон(белая(ый))
		case 4:
			if ((abs((y1 - y)) != abs((x1 - x))) || (abs(y1 - y)>7)) //если модули раностей двух координат не равны, то ход не возможен 
			{
				return 0;
				break;
			}
			if ((y1 - y)>0) //игрок ходит в нижнюю часть доски
			{
				if ((x1 - x)>0) //игрок ходит в нижнюю правую часть доски
				{
					for (i = y+1, j = x+1; i<y1; i++, j++)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((x1 - x)<0) //игрок ходит в нижнюю левую часть доски
				{
					for (i = y+1, j = x-1; (i<y1)&&(j>x1); i++, j--)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if ((y1 - y)<0) //игрок ходит в верхнюю часть доски
			{
				if ((x1 - x)>0) //игрок ходит в нижнюю правую часть доски
				{
					for (i = y - 1, j = x + 1; i > y1; i--, j++)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((x1 - x)<0) //игрок ходит в нижнюю левую часть доски
				{
					for (i = y-1, j = x-1; (i > y1) && (j > x1); i--, j--)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			k++;
			cout << " " << k << endl;
			if ((k == (y1 - y)) || (k == (y - y1)) || (k == (x1 - x)) || (k == (x - x1)))
			{
				if ((a[y1][x1]>0) && (a[y1][x1] <= 6)) return 3;
				if (a[y1][x1] >= 7) return 2;
				return 1;
			}
			else return 0;
			break;
			//ферзь(белая(ый))
		case 5:
			if ((((x1 != x) && (y1 != y)) && ((abs(y1 - y) != abs(x1 - x)))) || (abs(y1 - y) > 7))
			{
				return 0;
				break;
			}
			if (x1 == x) //игрок ходит по вертикали 
			{
				if ((y1 - y)>0) //игрок ходит в нижнюю часть доски
				{
					for (i = y + 1; i < y1; i++)
					{
						if (a[i][x] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((y1 - y)<0) // игрок ходит в верхнюю часть доски
				{
					for (i = y - 1; i > y1; i--)
					{
						if (a[i][x] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if (y1 == y) //игрок ходит по горизонтале 
			{
				if ((x1 - x)>0) //игрок ходит в правую часть доски
				{
					for (i = x + 1; i < x1; i++)
					{
						if (a[y][i] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((x1 - x)<0) // игрок ходит в левую часть доски
				{
					for (i = x - 1; i > x1; i--)
					{
						if (a[y][i] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if ((y1 - y)>0) //игрок ходит в нижнюю часть доски
			{
				if ((x1 - x)>0) //игрок ходит в нижнюю правую часть доски
				{
					for (i = y + 1, j = x + 1; i < y1; i++, j++)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((x1 - x)<0) //игрок ходит в нижнюю левую часть доски
				{
					for (i = y + 1, j = x - 1; (i < y1) && (j > x1); i++, j--)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if ((y1 - y)<0) //игрок ходит в верхнюю часть доски
			{
				if ((x1 - x)>0) //игрок ходит в нижнюю правую часть доски
				{
					for (i = y - 1, j = x + 1; i > y1; i--, j++)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((x1 - x)<0) //игрок ходит в нижнюю левую часть доски
				{
					for (i = y - 1, j = x - 1; (i > y1) && (j > x1); i--, j--)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			k++;
			if (((x == x1) && (abs(y - y1) == k)) || ((y == y1) && (abs(x - x1) == k))
				|| ((k == abs(y1 - y)) && ((x1 != x) && (y1 != y)) || ((k == abs(x1 - x)) && ((x1 != x) && (y1 != y)))))
			{
				if (((a[y1][x1]) != 0) && ((a[y1][x1] / 7) == 0)) return 3;
				if (a[y1][x1] >= 7) return 2;
				return 1;
			}
			else return 0;
			break;

			//король(белая(ый))
		case 6:
			if ((abs(y1 - y) > 1) || (abs(x1 - x) > 1)) return 0;//если модуль разностей двух координат больше единицы(то есть кол-во клеток между координатами хода больше единица), то ход не возможен 
			if (a[y1][x1] / 7 == 0) return 3;//alliance
			else if (a[y1][x1] / 7 == 1) return 2;//attack
			else return 1;
			break;

			//пешка(черная(ый))
		case 7:
			if ((a[y1][x1] == 0) && (y == 1))
				if ((&a[y + 1][x] == &a[y1][x1]) || (&a[y + 2][x] == &a[y1][x1])) return 1; // normal move, изначальное положение пешки, возможен ход через клетку
			if ((a[y1][x1] == 0))
				if ((&a[y + 1][x] == &a[y1][x1])) return 1; // normal move, любое положение пешки, возможен ход только на клетку вперед
			if ((a[y][x] / 7 != a[y1][x1] / 7))
			{
				if ((&a[y + 1][x + 1] == &a[y1][x1]) || (&a[y + 1][x - 1] == &a[y1][x1])) return 2;
			} // attack
			if ((&a[y + 1][x + 1] == &a[y1][x1]) || (&a[y + 1][x - 1] == &a[y1][x1])) return 3; // alliance
			return 0;
			break;
		}
	}
	else return 4;
}
int main()
{
  int i, i1, turn, pass,**a;
  char j, j1;
  a = new int*[8];
  for(int i =0;i<8;i++)
   a[i]= new int[8];
    /*описываем все элементы шахмотной доски где:
    1-пешка 4-ладья 3-конь 2-слон 5-ферзь 6-король
    знаком минус помеченна команда черных (не людей)*/
    a[7][0] = 2; a[6][0] = 1;
    a[7][1] = 3; a[6][1] = 1;
    a[7][2] = 4; a[6][2] = 1;
    a[7][3] = 6; a[6][3] = 1;
    a[7][4] = 5; a[6][4] = 1;
    a[7][5] = 4; a[6][5] = 1;
    a[7][6] = 3; a[6][6] = 1;
    a[7][7] = 2; a[6][7] = 1;

    a[2][0] = 0; a[3][0] = 0;
    a[2][1] = 0; a[3][1] = 0;
    a[2][2] = 0; a[3][2] = 0;
    a[2][3] = 0; a[3][3] = 0;
    a[2][4] = 0; a[3][4] = 0;
    a[2][5] = 0; a[3][5] = 0;
    a[2][6] = 0; a[3][6] = 0;
    a[2][7] = 0; a[3][7] = 0;

    a[4][0] = 0; a[5][0] = 0;
    a[4][1] = 0; a[5][1] = 0;
    a[4][2] = 0; a[5][2] = 0;
    a[4][3] = 0; a[5][3] = 0;
    a[4][4] = 0; a[5][4] = 0;
    a[4][5] = 0; a[5][5] = 0;
    a[4][6] = 0; a[5][6] = 0;
    a[4][7] = 0; a[5][7] = 0;

    a[0][0] = 8; a[1][0] = 7;
    a[0][1] = 9; a[1][1] = 7;
    a[0][2] = 10; a[1][2] = 7;
    a[0][3] = 11; a[1][3] = 7;
    a[0][4] = 12; a[1][4] = 7;
    a[0][5] = 10; a[1][5] = 7;
    a[0][6] = 9; a[1][6] = 7;
    a[0][7] = 8; a[1][7] = 7;

    //вывод первоначальной доски, вот такой скучный комментарий 
    while(1)
        {
        stdout_chess(a);
	printf("\n");
	//123
	//ввод координат, где i и j	- кординаты из которых нужно походить, а i1 и j1 - координаты в которые нужно походить, да-да я знаю что можно было сделать лучше 
       	printf("input number: ");
	//	scanf("%d", &i);
	cin >> i; 
	printf("input char: ");
	cin >> j;
	//	scanf("%c", &j);
	printf("input number to: ");
	cin>>i1;
	//	scanf("%d", &i1);
	printf("input char to: ");
	cin>>j1;
	//	scanf("%c", &j1);
	if (i==0) return 0;
	i--;
	i1--;
        j-='a';
	j1-='a';
        pass = 0;
	printf("%d\n%d\n",j, j1);
	if ((i>=0)&&(i<8)&&(j>=0)&&(j<8)&&(i1>=0)&&(i1<8)&&(j1>=0)&&(j1<8))
	{
	printf("Pass = %d\n", CheckMove(a, i,j, i1, j1));
	pass = CheckMove(a, i, j, i1, j1);
	}	
	if (pass == 0) printf("Cake\n");
	if (pass == 3) printf("Cake\n");
	if (pass == 1)
	  {
	    SwapMove(&a[i][j], &a[i1][j1]);
	  }
	if (pass == 2)
	  {
	    SwapMove(&a[i][j], &a[i1][j1]);
	  }
	if (pass == 4) printf("Cakeislie\n");
	//вызов функции в которой описанны все случаи ходов, нет, я не переборщил засунов все в одну функцию p.s. смотреть выше в начале проге
	system("Pause");
	system("CLS");
    }
    return 0;
}
