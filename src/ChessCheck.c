//#include <iostream>
#include<stdlib.h>
#include<stdio.h>

int CheckMove(int a[8][8], int y, int x, int y1, int x1)
{
	int chmove, CheckPlace, k = 0, i, j;
	if (a[y][x] != 0)
	{
		if (a[y][x] > 7) chmove = a[y][x]%6;
		else chmove = a[y][x];
		switch (chmove)
		{
		case 1:
			if ((a[y1][x1] == 0) && (y == 6))
				if ((&a[y - 1][x] == &a[y1][x1]) || (&a[y - 2][x] == &a[y1][x1])) return 1; 
			if (a[y1][x1] == 0)
				if ((&a[y - 1][x] == &a[y1][x1])) return 1; 
			if ((a[y][x] / 7 != a[y1][x1] / 7))
			{
				if ((&a[y - 1][x + 1] == &a[y1][x1]) || (&a[y - 1][x - 1] == &a[y1][x1])) return 2;
			} 
			if ((&a[y - 1][x + 1] == &a[y1][x1]) || (&a[y - 1][x - 1] == &a[y1][x1])) return 3; 
			return 0;
			break;
		      
		case 2:
			if ((x1 != x) && (y1 != y)) return 0; 
			if (x1 == x) 
			{
				if ((y1 - y)>0) //игрок ходит в нижнюю часть доски
				{
					for (i = y+1; i<y1; i++)
					{
						if (a[i][x] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((y1 - y)<0) // игрок ходит в верхнюю часть доски
				{
					for (i = y-1; i>y1; i--)
					{
						if (a[i][x] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if (y1 == y) //игрок ходит по горизонтале 
			{
				if ((x1 - x)>0) //игрок ходит в правую часть доски
				{
					for (i = x+1; i<x1; i++)
					{
						if (a[y][i] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((x1 - x)<0) // игрок ходит в левую часть доски
				{
					for (i = x-1; i>x1; i--)
					{
						if (a[y][i] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			k++;
			if (((x == x1) && (abs(y - y1) == k)) || ((y == y1) && (abs(x - x1) == k)))
			{
				if (((a[y1][x1]) != 0) && (a[y1][x1] / 7 == 0)) return 3;
				else if (a[y1][x1] >= 7) return 2;
				return 1;
			}
			else return 0; // attack
			break;
			//конь(белая(ый))
		case 3:
			if (((abs(x1 - x) == 1) && (abs(y1 - y) == 2)) || ((abs(x1 - x) == 2) && (abs(y1 - y) == 1)))
			{
				if (a[y1][x1] == 0) return 1;
				else if (((a[y1][x1]) != 0) && (a[y1][x1] / 7 == 0)) return 3;
				else return 2;
			}
			else return 0;
			break;
			//слон(белая(ый))
		case 4:
			if ((abs((y1 - y)) != abs((x1 - x))) || (abs(y1 - y)>7)) //если модули раностей двух координат не равны, то ход не возможен 
			{
				return 0;
				break;
			}
			if ((y1 - y)>0) //игрок ходит в нижнюю часть доски
			{
				if ((x1 - x)>0) //игрок ходит в нижнюю правую часть доски
				{
					for (i = y+1, j = x+1; i<y1; i++, j++)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((x1 - x)<0) //игрок ходит в нижнюю левую часть доски
				{
					for (i = y+1, j = x-1; (i<y1)&&(j>x1); i++, j--)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if ((y1 - y)<0) //игрок ходит в верхнюю часть доски
			{
				if ((x1 - x)>0) //игрок ходит в нижнюю правую часть доски
				{
					for (i = y - 1, j = x + 1; i > y1; i--, j++)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((x1 - x)<0) //игрок ходит в нижнюю левую часть доски
				{
					for (i = y-1, j = x-1; (i > y1) && (j > x1); i--, j--)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			k++;
			if ((k == (y1 - y)) || (k == (y - y1)) || (k == (x1 - x)) || (k == (x - x1)))
			{
				if ((a[y1][x1]>0) && (a[y1][x1] <= 6)) return 3;
				if (a[y1][x1] >= 7) return 2;
				return 1;
			}
			else return 0;
			break;
			//ферзь(белая(ый))
		case 5:
			if ((((x1 != x) && (y1 != y)) && ((abs(y1 - y) != abs(x1 - x)))) || (abs(y1 - y) > 7))
			{
				return 0;
				break;
			}
			if (x1 == x) //игрок ходит по вертикали 
			{
				if ((y1 - y)>0) //игрок ходит в нижнюю часть доски
				{
					for (i = y + 1; i < y1; i++)
					{
						if (a[i][x] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((y1 - y)<0) // игрок ходит в верхнюю часть доски
				{
					for (i = y - 1; i > y1; i--)
					{
						if (a[i][x] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if (y1 == y) //игрок ходит по горизонтале 
			{
				if ((x1 - x)>0) //игрок ходит в правую часть доски
				{
					for (i = x + 1; i < x1; i++)
					{
						if (a[y][i] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((x1 - x)<0) // игрок ходит в левую часть доски
				{
					for (i = x - 1; i > x1; i--)
					{
						if (a[y][i] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if ((y1 - y)>0) //игрок ходит в нижнюю часть доски
			{
				if ((x1 - x)>0) //игрок ходит в нижнюю правую часть доски
				{
					for (i = y + 1, j = x + 1; i < y1; i++, j++)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((x1 - x)<0) //игрок ходит в нижнюю левую часть доски
				{
					for (i = y + 1, j = x - 1; (i < y1) && (j > x1); i++, j--)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			if ((y1 - y)<0) //игрок ходит в верхнюю часть доски
			{
				if ((x1 - x)>0) //игрок ходит в нижнюю правую часть доски
				{
					for (i = y - 1, j = x + 1; i > y1; i--, j++)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
				if ((x1 - x)<0) //игрок ходит в нижнюю левую часть доски
				{
					for (i = y - 1, j = x - 1; (i > y1) && (j > x1); i--, j--)
					{
						if (a[i][j] == 0) k++;
						//ставим счетчик который проверяет условие наличия фигур между координатами хода, если фигур нет, то k = числу проверок, тоесть кол-ву клеток между координатами хода
					}
				}
			}
			k++;
			if (((x == x1) && (abs(y - y1) == k)) || ((y == y1) && (abs(x - x1) == k))
				|| ((k == abs(y1 - y)) && ((x1 != x) && (y1 != y)) || ((k == abs(x1 - x)) && ((x1 != x) && (y1 != y)))))
			{
				if (((a[y1][x1]) != 0) && ((a[y1][x1] / 7) == 0)) return 3;
				if (a[y1][x1] >= 7) return 2;
				return 1;
			}
			else return 0;
			break;


		case 6:
			if ((abs(y1 - y) > 1) || (abs(x1 - x) > 1)) return 0;//если модуль разностей двух координат больше единицы(то есть кол-во клеток между координатами хода больше единица), то ход не возможен 
			if (a[y1][x1] / 7 == 0) return 3;//alliance
			else if (a[y1][x1] / 7 == 1) return 2;//attack
			else return 1;
			break;

			//пешка(черная(ый))
		case 7:
			if ((a[y1][x1] == 0) && (y == 1))
				if ((&a[y + 1][x] == &a[y1][x1]) || (&a[y + 2][x] == &a[y1][x1])) return 1; // normal move, изначальное положение пешки, возможен ход через клетку
			if ((a[y1][x1] == 0))
				if ((&a[y + 1][x] == &a[y1][x1])) return 1; // normal move, любое положение пешки, возможен ход только на клетку вперед
			if ((a[y][x] / 7 != a[y1][x1] / 7))
			{
				if ((&a[y + 1][x + 1] == &a[y1][x1]) || (&a[y + 1][x - 1] == &a[y1][x1])) return 2;
			} // attack
			if ((&a[y + 1][x + 1] == &a[y1][x1]) || (&a[y + 1][x - 1] == &a[y1][x1])) return 3; // alliance
			return 0;
			break;
		}
	}
	else return 4;
}
